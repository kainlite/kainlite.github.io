<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech experiments</title>
    <link>https://kainlite.github.io/</link>
    <description>Recent content on Tech experiments</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 29 Dec 2018 00:00:00 +0000</lastBuildDate>
    
        <atom:link href="https://kainlite.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Go echo bot</title>
      <link>https://kainlite.github.io/blog/go_echobot/</link>
      <pubDate>Sat, 29 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kainlite.github.io/blog/go_echobot/</guid>
      <description>

&lt;h3 id=&#34;echo-bot&#34;&gt;&lt;strong&gt;Echo bot&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;To be honest, there is no other way to get the benefits of having &lt;a href=&#34;https://ksonnet.io/&#34;&gt;ksonnet&lt;/a&gt; if you&amp;rsquo;re not going to take advantage of the &lt;em&gt;deployments as code&lt;/em&gt; facilities that it brings thanks to Jsonnet.&lt;/p&gt;

&lt;p&gt;In the examples I will be using &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-minikube&#34;&gt;minikube&lt;/a&gt; or you can &lt;a href=&#34;https://github.com/kainlite/kainlite.github.io&#34;&gt;check out this repo&lt;/a&gt; that has a good overview of minikube, once installed and started (&lt;code&gt;minikube start&lt;/code&gt;) that command will download and configure the local environment, if you have been following the previous posts you already have minikube installed and working:&lt;/p&gt;

&lt;p&gt;This time we will see how to use &lt;a href=&#34;https://github.com/cybermaggedon/ksonnet-cheat-sheet&#34;&gt;proper templates&lt;/a&gt;, it seems that the templates generated with &lt;code&gt;ks&lt;/code&gt; are outdated at the time of this writing ksonnet version is: 0.13.1, no surprise here but it&amp;rsquo;s not a really mature tool. It does require a lot of effort in learning, hacking and reading to get things to work, but hopefully soon it will be easier, of course this is my personal opinion and I have not used it for a real project yet, but I expect it to grow and become more usable before I attempt to do something for the real world with it.&lt;/p&gt;

&lt;h3 id=&#34;let-s-get-started&#34;&gt;Let&amp;rsquo;s get started&lt;/h3&gt;

&lt;p&gt;This time I&amp;rsquo;m not going to deploy another wordpress instance but a simple Slack echo bot made with go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
        &amp;quot;fmt&amp;quot;
        &amp;quot;os&amp;quot;
        &amp;quot;strings&amp;quot;

        slack &amp;quot;github.com/nlopes/slack&amp;quot;
)

func main() {
        api := slack.New(
                os.Getenv(&amp;quot;SLACK_API_TOKEN&amp;quot;),
        )

        rtm := api.NewRTM()
        go rtm.ManageConnection()

        for msg := range rtm.IncomingEvents {
                fmt.Print(&amp;quot;Event Received: &amp;quot;)
                switch ev := msg.Data.(type) {
                case *slack.HelloEvent:
                        // Ignore hello

                case *slack.ConnectedEvent:
                        fmt.Println(&amp;quot;Infos:&amp;quot;, ev.Info)
                        fmt.Println(&amp;quot;Connection counter:&amp;quot;, ev.ConnectionCount)

                case *slack.MessageEvent:
                        // Only echo what it said to me
                        fmt.Printf(&amp;quot;Message: %v\n&amp;quot;, ev)
                        info := rtm.GetInfo()
                        prefix := fmt.Sprintf(&amp;quot;&amp;lt;@%s&amp;gt; &amp;quot;, info.User.ID)

                        if ev.User != info.User.ID &amp;amp;&amp;amp; strings.HasPrefix(ev.Text, prefix) {
                                rtm.SendMessage(rtm.NewOutgoingMessage(ev.Text, ev.Channel))
                        }

                case *slack.PresenceChangeEvent:
                        fmt.Printf(&amp;quot;Presence Change: %v\n&amp;quot;, ev)

                case *slack.LatencyReport:
                        fmt.Printf(&amp;quot;Current latency: %v\n&amp;quot;, ev.Value)

                case *slack.RTMError:
                        fmt.Printf(&amp;quot;Error: %s\n&amp;quot;, ev.Error())

                case *slack.InvalidAuthEvent:
                        fmt.Printf(&amp;quot;Invalid credentials&amp;quot;)
                        return

                default:

                        // Ignore other events..
                        // fmt.Printf(&amp;quot;Unexpected: %v\n&amp;quot;, msg.Data)
                }
        }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see it&amp;rsquo;s the simplest example from the wiki of the &lt;a href=&#34;https://github.com/nlopes/slack&#34;&gt;Go Slack API&lt;/a&gt; wiki page, it only connects to Slack and when it reads a message if it&amp;rsquo;s addressed to the bot then it echoes the message back, creating a bot and everything else is out of the scope of this article but it&amp;rsquo;s really simple, you only need to create an app in the Slack workspace, set it as a bot and grab the token (there is a lot more that you can customize but that is the most basic procedure to get started with a bot), then you just invite it to any channel that you want and start interacting with it.&lt;/p&gt;

&lt;p&gt;Here you can see the &lt;code&gt;Dockerfile&lt;/code&gt;, for security we create an app user for the build and for running it, and to save space and bandwidth we only ship what we need using a multi-stage build:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;# Build
FROM golang:1.11.2-alpine as builder

WORKDIR /app
RUN adduser -D -g &#39;app&#39; app &amp;amp;&amp;amp; \
    chown -R app:app /app &amp;amp;&amp;amp; \
    apk add git &amp;amp;&amp;amp; apk add gcc musl-dev

ADD . /app/
RUN go get -d -v ./... &amp;amp;&amp;amp; go build -o main . &amp;amp;&amp;amp; chown -R app:app /app /home/app

# Run
FROM golang:1.11.2-alpine

WORKDIR /app
RUN adduser -D -g &#39;app&#39; app &amp;amp;&amp;amp; \
    chown -R app:app /app

COPY --from=builder --chown=app /app/main /app/main

USER app
CMD [&amp;quot;/app/main&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are a few more files in there, you can see the full sources &lt;a href=&#34;https://github.com/kainlite/echobot&#34;&gt;here&lt;/a&gt;, for example &lt;code&gt;health_check.sh&lt;/code&gt;, as our app doesn&amp;rsquo;t listen on any port we need a way to tell kubernetes how to check or know that our app is alive, otherwise it will murder the pod over and over again.&lt;/p&gt;

&lt;p&gt;Okay, enough boilerplate let&amp;rsquo;s get to business, so let&amp;rsquo;s create a new ksonnet application:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ks init echobot
INFO Using context &amp;quot;minikube&amp;quot; from kubeconfig file &amp;quot;/home/kainlite/.kube/config&amp;quot;
INFO Creating environment &amp;quot;default&amp;quot; with namespace &amp;quot;default&amp;quot;, pointing to &amp;quot;version:v1.8.0&amp;quot; cluster at address &amp;quot;https://192.168.99.100:8443&amp;quot;
INFO Generating ksonnet-lib data at path &#39;/home/kainlite/Webs/echobot/echobot/lib/ksonnet-lib/v1.8.0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now based let&amp;rsquo;s create the deployment for it &lt;code&gt;echobot.jsonnet&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Import KSonnet library
local params = std.extVar(&#39;__ksonnet/params&#39;).components.demo;
local k = import &#39;k.libsonnet&#39;;

// Specify the import objects that we need
local container = k.extensions.v1beta1.deployment.mixin.spec.template.spec.containersType;
local depl = k.extensions.v1beta1.deployment;

// Environment variables, instead of hardcoding it here we could use a param or a secret
// But I will leave that as an exercise for you :)
local envs = [
  {
    name: &#39;SLACK_API_TOKEN&#39;,
    value: &#39;really-long-token&#39;,
  },
];

// Define containers
local containers = [
  container.new(&#39;echobot&#39;, &#39;kainlite/echobot:0.0.1&#39;) {
    env: (envs),
  },
];

// Define deployment with 3 replicas
local deployment =
  depl.new(&#39;echobot&#39;, 1, containers, { app: &#39;echobot&#39; });

local resources = [deployment];

// Return list of resources.
k.core.v1.list.new(resources)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I have uploaded that image to docker hub so you can use it to follow the example if you want, after that just replace &lt;code&gt;really-long-token&lt;/code&gt; with your token, and then do:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;$ ks apply default
INFO Applying deployments echobot
INFO Creating non-existent deployments echobot
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now if we check our deployment and pod, we should see something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kainlite.github.io/img/echobot.png&#34; alt=&#34;Echo bot&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And in the logs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt; $ kubectl get pods
NAME                               READY     STATUS    RESTARTS   AGE
echobot-7456f7d7dd-twg4r           1/1       Running   0          53s

$ kubectl logs -f echobot-7456f7d7dd-twg4r
Event Received: Event Received: Infos: &amp;amp;{wss://cerberus-xxxx.lb.slack-msgs.com/websocket/1gvXP_yQCFE-Y= 0xc000468000 0xc0004482a0 [] [] [] [] []}
Connection counter: 0
Event Received: Event Received: Current latency: 1.256397423s
Event Received: Current latency: 1.25679313s
Event Received: Current latency: 1.256788737s
Event Received: Message: &amp;amp;{{message CEDGU6EA0 UEDJT5DDH &amp;lt;@UED48HD33&amp;gt; echo! 1546124966.002300  false [] [] &amp;lt;nil&amp;gt;  false 0  false  1546124966.002300   &amp;lt;nil&amp;gt;      [] 0 []  [] false &amp;lt;nil&amp;gt;  0 TEDJT5CTD []  false false} &amp;lt;nil&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that folks is all I have for now, I hope you enjoyed this small tour of ksonnet. The source code for the bot can be found &lt;a href=&#34;here&#34;&gt;https://github.com/kainlite/echobot&lt;/a&gt;. In a future post I might explore &lt;a href=&#34;https://ksonnet.io/docs/examples/helm/&#34;&gt;ksonnet and helm charts&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;upcoming-topics&#34;&gt;Upcoming topics&lt;/h3&gt;

&lt;p&gt;As promised I will be doing one post about &lt;a href=&#34;https://github.com/hasura/gitkube&#34;&gt;Gitkube&lt;/a&gt; and &lt;a href=&#34;https://github.com/GoogleContainerTools/skaffold&#34;&gt;Skaffold&lt;/a&gt;, there are a lot of deployment tools for kubernetes but those are the most promising ones to me, also after that I will start covering more topics about &lt;a href=&#34;https://www.docker.com/&#34;&gt;Docker&lt;/a&gt;, &lt;a href=&#34;https://containerd.io/&#34;&gt;ContainerD&lt;/a&gt;, &lt;a href=&#34;https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/&#34;&gt;KubeADM&lt;/a&gt;, and Kubernetes in general.&lt;/p&gt;

&lt;h3 id=&#34;errata&#34;&gt;Errata&lt;/h3&gt;

&lt;p&gt;If you spot any error or have any suggestion, please send me a message so it gets fixed.&lt;/p&gt;

&lt;p&gt;Also, you can check the source code and changes in the &lt;a href=&#34;https://github.com/kainlite/kainlite.github.io&#34;&gt;generated code&lt;/a&gt; and the &lt;a href=&#34;https://github.com/kainlite/blog&#34;&gt;sources here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with ksonnet</title>
      <link>https://kainlite.github.io/blog/getting_started_with_ksonnet/</link>
      <pubDate>Thu, 27 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kainlite.github.io/blog/getting_started_with_ksonnet/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;This tutorial will show you how to create a simple application and also how to deploy it to kubernetes using &lt;a href=&#34;https://ksonnet.io/&#34;&gt;ksonnet&lt;/a&gt;, in the examples I will be using &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-minikube&#34;&gt;minikube&lt;/a&gt; or you can &lt;a href=&#34;https://github.com/kainlite/kainlite.github.io&#34;&gt;check out this repo&lt;/a&gt; that has a good overview of minikube, once installed and started (&lt;code&gt;minikube start&lt;/code&gt;) that command will download and configure the local environment, if you have been following the previous posts you already have minikube installed and working, before we dive into an example let&amp;rsquo;s review some terminology from ksonnet (extracted from the &lt;a href=&#34;https://ksonnet.io/docs/concepts/&#34;&gt;official documentation&lt;/a&gt;):&lt;/p&gt;

&lt;h4 id=&#34;application&#34;&gt;Application&lt;/h4&gt;

&lt;p&gt;A ksonnet application represents a well-structured directory of Kubernetes manifests (this is generated using the &lt;code&gt;ks init&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;environment&#34;&gt;Environment&lt;/h4&gt;

&lt;p&gt;An environment consists of four elements, some of which can be pulled from your current kubeconfig context: Name, Server, Namespace, API version. The environment determines to which cluster you&amp;rsquo;re going to deploy the application.&lt;/p&gt;

&lt;h4 id=&#34;component&#34;&gt;Component&lt;/h4&gt;

&lt;p&gt;A component can be as simple as a Kubernetes resource (a Pod, Deployment, etc), or a fully working stack for example EFK/ELK, you can generate components using &lt;code&gt;ks generate&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;prototype&#34;&gt;Prototype&lt;/h4&gt;

&lt;p&gt;Prototype + Parameters = Component. Think of a prototype as a base template before you apply the parameters, to set a name, replicas, etc for the resource, you can explore some system prototypes with &lt;code&gt;ks prototype&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;parameter&#34;&gt;Parameter&lt;/h4&gt;

&lt;p&gt;It gives live to a component with dynamic values, you can use &lt;code&gt;ks param&lt;/code&gt; to view or modify params, there are App params (global), Component params, and Environment params (overrides app params).&lt;/p&gt;

&lt;h4 id=&#34;module&#34;&gt;Module&lt;/h4&gt;

&lt;p&gt;Modules provide a way for you to share components across environments. More concisely, a module refers to a subdirectory in components/ containing its own params.libsonnet. To create a module &lt;code&gt;ks module create &amp;lt;module name&amp;gt;&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;part&#34;&gt;Part&lt;/h4&gt;

&lt;p&gt;It provides a way to organize and re-use code.&lt;/p&gt;

&lt;h4 id=&#34;package&#34;&gt;Package&lt;/h4&gt;

&lt;p&gt;A package is a set of related prototypes and associates helper libraries, it allows you to create and share packages between applications.&lt;/p&gt;

&lt;h4 id=&#34;registry&#34;&gt;Registry&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s essentially a repository for packages, it supports the incubator registry, github, filesystem, and Helm.&lt;/p&gt;

&lt;h4 id=&#34;manifest&#34;&gt;Manifest&lt;/h4&gt;

&lt;p&gt;The same old YAML or JSON manifest but this time written in &lt;a href=&#34;https://jsonnet.org/learning/tutorial.html&#34;&gt;Jsonnet&lt;/a&gt;, basically Jsonnet is a simple extension of JSON.&lt;/p&gt;

&lt;p&gt;Phew, that&amp;rsquo;s a lot of names and terminology at once, let&amp;rsquo;s get started with the terminal already.&lt;/p&gt;

&lt;h3 id=&#34;let-s-get-started&#34;&gt;Let&amp;rsquo;s get started&lt;/h3&gt;

&lt;p&gt;This command will generate the following folder structure &lt;code&gt;ks init wordpress&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;INFO Using context &amp;quot;minikube&amp;quot; from kubeconfig file &amp;quot;~/.kube/config&amp;quot;
INFO Creating environment &amp;quot;default&amp;quot; with namespace &amp;quot;default&amp;quot;, pointing to &amp;quot;version:v1.12.4&amp;quot; cluster at address &amp;quot;https://192.168.99.100:8443&amp;quot;
INFO Generating ksonnet-lib data at path &#39;~/k8s-examples/wordpress/lib/ksonnet-lib/v1.12.4&#39;

$ ls -l |  awk &#39;{ print $9 }&#39;
app.yaml        &amp;lt;--- Defines versions, namespace, cluster address, app name, registry.
components      &amp;lt;--- Components by default it&#39;s empty and has a params file.
environments    &amp;lt;--- By default there is only one environment called default.
lib             &amp;lt;--- Here we can find the ksonnet helpers that match the Kubernetes API with the common resources (Pods, Deployments, etc).
vendor          &amp;lt;--- Here is where the installed packages/apps go, it can be seen as a dependencies folder.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s generate a &lt;em&gt;deployed-service&lt;/em&gt; and inspect it&amp;rsquo;s context:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ks generate deployed-service wordpress \
  --image bitnami/wordpress:5.0.2 \
  --type ClusterIP

INFO Writing component at &#39;~/k8s-examples/wordpress/components/wordpress.jsonnet&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the moment of this writing the latest version of Wordpress is 5.0.2, it&amp;rsquo;s always recommended to use static version numbers instead of tags like latest (because latest can not be latest).&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see how our component looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;local env = std.extVar(&amp;quot;__ksonnet/environments&amp;quot;);
local params = std.extVar(&amp;quot;__ksonnet/params&amp;quot;).components.wordpress;
[
  {
    &amp;quot;apiVersion&amp;quot;: &amp;quot;v1&amp;quot;,
    &amp;quot;kind&amp;quot;: &amp;quot;Service&amp;quot;,
    &amp;quot;metadata&amp;quot;: {
      &amp;quot;name&amp;quot;: params.name
    },
    &amp;quot;spec&amp;quot;: {
      &amp;quot;ports&amp;quot;: [
        {
          &amp;quot;port&amp;quot;: params.servicePort,
          &amp;quot;targetPort&amp;quot;: params.containerPort
        }
      ],
      &amp;quot;selector&amp;quot;: {
        &amp;quot;app&amp;quot;: params.name
      },
      &amp;quot;type&amp;quot;: params.type
    }
  },
  {
    &amp;quot;apiVersion&amp;quot;: &amp;quot;apps/v1beta2&amp;quot;,
    &amp;quot;kind&amp;quot;: &amp;quot;Deployment&amp;quot;,
    &amp;quot;metadata&amp;quot;: {
      &amp;quot;name&amp;quot;: params.name
    },
    &amp;quot;spec&amp;quot;: {
      &amp;quot;replicas&amp;quot;: params.replicas,
      &amp;quot;selector&amp;quot;: {
        &amp;quot;matchLabels&amp;quot;: {
          &amp;quot;app&amp;quot;: params.name
        },
      },
      &amp;quot;template&amp;quot;: {
        &amp;quot;metadata&amp;quot;: {
          &amp;quot;labels&amp;quot;: {
            &amp;quot;app&amp;quot;: params.name
          }
        },
        &amp;quot;spec&amp;quot;: {
          &amp;quot;containers&amp;quot;: [
            {
              &amp;quot;image&amp;quot;: params.image,
              &amp;quot;name&amp;quot;: params.name,
              &amp;quot;ports&amp;quot;: [
                {
                  &amp;quot;containerPort&amp;quot;: params.containerPort
                }
              ]
            }
          ]
        }
      }
    }
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s just another template for some known resources, a &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34;&gt;service&lt;/a&gt; and a &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/deployment/&#34;&gt;deployment&lt;/a&gt; that&amp;rsquo;s where the name came from: &lt;em&gt;deployed-service&lt;/em&gt;, but where are those params coming from?&lt;/p&gt;

&lt;p&gt;If we run &lt;code&gt;ks show default&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
apiVersion: v1
kind: Service
metadata:
  labels:
    ksonnet.io/component: wordpress
  name: wordpress
spec:
  ports:
  - port: 80
    targetPort: 80
  selector:
    app: wordpress
  type: ClusterIP
---
apiVersion: apps/v1beta2
kind: Deployment
metadata:
  labels:
    ksonnet.io/component: wordpress
  name: wordpress
spec:
  replicas: 1
  selector:
    matchLabels:
      app: wordpress
  template:
    metadata:
      labels:
        app: wordpress
    spec:
      containers:
      - image: bitnami/wordpress:5.0.2
        name: wordpress
        ports:
        - containerPort: 80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will see what our package will generate in &lt;em&gt;YAML&lt;/em&gt; with some good defaults. And by default if you remember from the definitions a component needs a params file to fill the blanks in this case it is &lt;code&gt;components/params.libsonnet&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  global: {
    // User-defined global parameters; accessible to all component and environments, Ex:
    // replicas: 4,
  },
  components: {
    // Component-level parameters, defined initially from &#39;ks prototype use ...&#39;
    // Each object below should correspond to a component in the components/ directory
    wordpress: {
      containerPort: 80,
      image: &amp;quot;bitnami/wordpress:5.0.2&amp;quot;,
      name: &amp;quot;wordpress&amp;quot;,
      replicas: 1,
      servicePort: 80,
      type: &amp;quot;ClusterIP&amp;quot;,
    },
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that&amp;rsquo;s not enough to run wordpress is it?, No is not, we need a database with persistent storage for it to work properly, so we will need to generate and extend another &lt;em&gt;deployed-service&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The next step would be to create another component:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ ks generate deployed-service mariadb \
  --image bitnami/mariadb:10.1.37 \
  --type ClusterIP

INFO Writing component at &#39;/home/kainlite/Webs/k8s-examples/wordpress/components/mariadb.jsonnet&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The latest stable version of MariaDB 10.1 GA at the moment of this writting is 10.1.37.&lt;/p&gt;

&lt;p&gt;Then we will need to add a persistent volume and also tell Wordpress to use this MariaDB instance. How do we do that, we will need to modify a few files, like this (in order to re-use things I placed the mysql variables in the global section, for this example that will simplify things, but it might not be the best approach for a production environment):
The resulting &lt;code&gt;components/params.json&lt;/code&gt; will be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  global: {
    // User-defined global parameters; accessible to all component and environments, Ex:
    // replicas: 4,
    mariadbEmptyPassword: &amp;quot;no&amp;quot;,
    mariadbUser: &amp;quot;mywordpressuser&amp;quot;,
    mariadbPassword: &amp;quot;mywordpresspassword&amp;quot;,
    mariadbDatabase: &amp;quot;bitnami_wordpress&amp;quot;,
  },
  components: {
    // Component-level parameters, defined initially from &#39;ks prototype use ...&#39;
    // Each object below should correspond to a component in the components/ directory
    wordpress: {
      containerPort: 80,
      image: &amp;quot;bitnami/wordpress:5.0.2&amp;quot;,
      name: &amp;quot;wordpress&amp;quot;,
      replicas: 1,
      servicePort: 80,
      type: &amp;quot;ClusterIP&amp;quot;,
    },
    mariadb: {
      containerPort: 3306,
      image: &amp;quot;bitnami/mariadb:10.1.37&amp;quot;,
      name: &amp;quot;mariadb&amp;quot;,
      replicas: 1,
      servicePort: 3306,
      type: &amp;quot;ClusterIP&amp;quot;,
    },
  },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The resulting &lt;code&gt;components/wordpress.jsonnet&lt;/code&gt; will be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;local env = std.extVar(&amp;quot;__ksonnet/environments&amp;quot;);
local params = std.extVar(&amp;quot;__ksonnet/params&amp;quot;).components.wordpress;
[
  {
    &amp;quot;apiVersion&amp;quot;: &amp;quot;v1&amp;quot;,
    &amp;quot;kind&amp;quot;: &amp;quot;Service&amp;quot;,
    &amp;quot;metadata&amp;quot;: {
      &amp;quot;name&amp;quot;: params.name
    },
    &amp;quot;spec&amp;quot;: {
      &amp;quot;ports&amp;quot;: [
        {
          &amp;quot;port&amp;quot;: params.servicePort,
          &amp;quot;targetPort&amp;quot;: params.containerPort
        }
      ],
      &amp;quot;selector&amp;quot;: {
        &amp;quot;app&amp;quot;: params.name
      },
      &amp;quot;type&amp;quot;: params.type
    }
  },
  {
    &amp;quot;apiVersion&amp;quot;: &amp;quot;apps/v1beta2&amp;quot;,
    &amp;quot;kind&amp;quot;: &amp;quot;Deployment&amp;quot;,
    &amp;quot;metadata&amp;quot;: {
      &amp;quot;name&amp;quot;: params.name
    },
    &amp;quot;spec&amp;quot;: {
      &amp;quot;replicas&amp;quot;: params.replicas,
      &amp;quot;selector&amp;quot;: {
        &amp;quot;matchLabels&amp;quot;: {
          &amp;quot;app&amp;quot;: params.name
        },
      },
      &amp;quot;template&amp;quot;: {
        &amp;quot;metadata&amp;quot;: {
          &amp;quot;labels&amp;quot;: {
            &amp;quot;app&amp;quot;: params.name
          }
        },
        &amp;quot;spec&amp;quot;: {
          &amp;quot;containers&amp;quot;: [
            {
              &amp;quot;image&amp;quot;: params.image,
              &amp;quot;name&amp;quot;: params.name,
              &amp;quot;ports&amp;quot;: [
                {
                  &amp;quot;containerPort&amp;quot;: params.containerPort
                }
              ],
              &amp;quot;env&amp;quot;: [
                {
                    &amp;quot;name&amp;quot;: &amp;quot;WORDPRESS_DATABASE_USER&amp;quot;,
                    &amp;quot;value&amp;quot;: params.mariadbUser,
                },
                {
                    &amp;quot;name&amp;quot;: &amp;quot;WORDPRESS_DATABASE_PASSWORD&amp;quot;,
                    &amp;quot;value&amp;quot;: params.mariadbPassword,
                },
                {
                    &amp;quot;name&amp;quot;: &amp;quot;WORDPRESS_DATABASE_NAME&amp;quot;,
                    &amp;quot;value&amp;quot;: params.mariadbDatabase,
                },
                {
                    &amp;quot;name&amp;quot;: &amp;quot;WORDPRESS_HOST&amp;quot;,
                    &amp;quot;value&amp;quot;: &amp;quot;mariadb&amp;quot;,
                }
              ]
            }
          ]
        }
      }
    }
  }
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only thing that changed here is &lt;code&gt;spec.containers.env&lt;/code&gt; which wasn&amp;rsquo;t present before.&lt;/p&gt;

&lt;p&gt;The resulting &lt;code&gt;components/mariadb.jsonnet&lt;/code&gt; will be:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;local env = std.extVar(&amp;quot;__ksonnet/environments&amp;quot;);
local params = std.extVar(&amp;quot;__ksonnet/params&amp;quot;).components.mariadb;
[
{
    &amp;quot;apiVersion&amp;quot;: &amp;quot;v1&amp;quot;,
        &amp;quot;kind&amp;quot;: &amp;quot;Service&amp;quot;,
        &amp;quot;metadata&amp;quot;: {
            &amp;quot;name&amp;quot;: params.name
        },
        &amp;quot;spec&amp;quot;: {
            &amp;quot;ports&amp;quot;: [
            {
                &amp;quot;port&amp;quot;: params.servicePort,
                &amp;quot;targetPort&amp;quot;: params.containerPort
            }
            ],
            &amp;quot;selector&amp;quot;: {
                &amp;quot;app&amp;quot;: params.name
            },
            &amp;quot;type&amp;quot;: params.type
        }
},
{
    &amp;quot;apiVersion&amp;quot;: &amp;quot;apps/v1beta2&amp;quot;,
    &amp;quot;kind&amp;quot;: &amp;quot;Deployment&amp;quot;,
    &amp;quot;metadata&amp;quot;: {
        &amp;quot;name&amp;quot;: params.name
    },
    &amp;quot;spec&amp;quot;: {
        &amp;quot;replicas&amp;quot;: params.replicas,
        &amp;quot;selector&amp;quot;: {
            &amp;quot;matchLabels&amp;quot;: {
                &amp;quot;app&amp;quot;: params.name
            },
        },
        &amp;quot;template&amp;quot;: {
            &amp;quot;metadata&amp;quot;: {
                &amp;quot;labels&amp;quot;: {
                    &amp;quot;app&amp;quot;: params.name
                }
            },
            &amp;quot;spec&amp;quot;: {
                &amp;quot;containers&amp;quot;: [
                {
                    &amp;quot;image&amp;quot;: params.image,
                    &amp;quot;name&amp;quot;: params.name,
                    &amp;quot;ports&amp;quot;: [
                    {
                        &amp;quot;containerPort&amp;quot;: params.containerPort
                    },
                    ],
                    &amp;quot;env&amp;quot;: [
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;ALLOW_EMPTY_PASSWORD&amp;quot;,
                        &amp;quot;value&amp;quot;: params.mariadbEmptyPassword,
                    },
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;MARIADB_USER&amp;quot;,
                        &amp;quot;value&amp;quot;: params.mariadbUser,
                    },
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;MARIADB_PASSWORD&amp;quot;,
                        &amp;quot;value&amp;quot;: params.mariadbPassword,
                    },
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;MARIADB_ROOT_PASSWORD&amp;quot;,
                        &amp;quot;value&amp;quot;: params.mariadbPassword,
                    },
                    {
                        &amp;quot;name&amp;quot;: &amp;quot;MARIADB_DATABASE&amp;quot;,
                        &amp;quot;value&amp;quot;: params.mariadbDatabase,
                    },
                    ],
                    &amp;quot;volumeMounts&amp;quot;: [
                    {
                        &amp;quot;mountPath&amp;quot;: &amp;quot;/var/lib/mysql&amp;quot;,
                        &amp;quot;name&amp;quot;: &amp;quot;mariadb&amp;quot;
                    }
                    ]
                }
                ],
                &amp;quot;volumes&amp;quot;: [
                {
                    &amp;quot;name&amp;quot;: &amp;quot;mariadb&amp;quot;,
                    &amp;quot;hostPath&amp;quot;: {
                        &amp;quot;path&amp;quot;: &amp;quot;/home/docker/mariadb-data&amp;quot;
                    }
                }
                ]
            }
        }
    }
}
]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I know, I know, that is a lot of JSON, I trust you have a decent scroll :).&lt;/p&gt;

&lt;p&gt;The only things that changed here are &lt;code&gt;spec.containers.env&lt;/code&gt;, &lt;code&gt;spec.containers.volumeMount&lt;/code&gt; and &lt;code&gt;spec.volumes&lt;/code&gt; which weren&amp;rsquo;t present before, that&amp;rsquo;s all you need to make wordpress work with mariadb.&lt;/p&gt;

&lt;p&gt;This post only scratched the surface of what Ksonnet and Jsonnet can do, in another post I will describe more advances features with less &lt;em&gt;JSON&lt;/em&gt; / &lt;em&gt;YAML&lt;/em&gt;. There are a lot of things that can be improved and we will cover those things in the next post, if you want to see all the source code for this post go &lt;a href=&#34;https://github.com/kainlite/ksonnet-wordpress-example&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s clean up &lt;code&gt;ks delete default&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;INFO Deleting services mariadb
INFO Deleting deployments mariadb
INFO Deleting services wordpress
INFO Deleting deployments wordpress
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;notes&#34;&gt;Notes&lt;/h3&gt;

&lt;p&gt;If you want to check the wordpress installation via browser you can do &lt;code&gt;minikube proxy&lt;/code&gt; and then look up the following URL: &lt;a href=&#34;http://localhost:8001/api/v1/namespaces/default/services/wordpress/proxy/&#34;&gt;Wordpress&lt;/a&gt; (I&amp;rsquo;m using the default namespace here and the service name is wordpress, if you use ingress you don&amp;rsquo;t need to do this step)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not aware if Ksonnet supports releases and rollbacks like Helm, but it seems it could be emulated using git tags and just some git hooks.&lt;/p&gt;

&lt;p&gt;If everything goes well, you should see something like this in the logs:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl logs -f wordpress-5b4d6bd47c-bdtmw

Welcome to the Bitnami wordpress container
Subscribe to project updates by watching https://github.com/bitnami/bitnami-docker-wordpress
Submit issues and feature requests at https://github.com/bitnami/bitnami-docker-wordpress/issues

nami    INFO  Initializing apache
apache  INFO  ==&amp;gt; Patching httpoxy...
apache  INFO  ==&amp;gt; Configuring dummy certificates...
nami    INFO  apache successfully initialized
nami    INFO  Initializing php
nami    INFO  php successfully initialized
nami    INFO  Initializing mysql-client
nami    INFO  mysql-client successfully initialized
nami    INFO  Initializing libphp
nami    INFO  libphp successfully initialized
nami    INFO  Initializing wordpress
mysql-c INFO  Trying to connect to MySQL server
mysql-c INFO  Found MySQL server listening at mariadb:3306
mysql-c INFO  MySQL server listening and working at mariadb:3306
wordpre INFO
wordpre INFO  ########################################################################
wordpre INFO   Installation parameters for wordpress:
wordpre INFO     First Name: FirstName
wordpre INFO     Last Name: LastName
wordpre INFO     Username: user
wordpre INFO     Password: **********
wordpre INFO     Email: user@example.com
wordpre INFO     Blog Name: User&#39;s Blog!
wordpre INFO     Table Prefix: wp_
wordpre INFO   (Passwords are not shown for security reasons)
wordpre INFO  ########################################################################
wordpre INFO
nami    INFO  wordpress successfully initialized
INFO  ==&amp;gt; Starting wordpress...
[Thu Dec 27 04:30:59.684053 2018] [ssl:warn] [pid 116] AH01909: localhost:443:0 server certificate does NOT include an ID which matches the server name
[Thu Dec 27 04:30:59.684690 2018] [ssl:warn] [pid 116] AH01909: localhost:443:0 server certificate does NOT include an ID which matches the server name
[Thu Dec 27 04:30:59.738783 2018] [ssl:warn] [pid 116] AH01909: localhost:443:0 server certificate does NOT include an ID which matches the server name
[Thu Dec 27 04:30:59.739701 2018] [ssl:warn] [pid 116] AH01909: localhost:443:0 server certificate does NOT include an ID which matches the server name
[Thu Dec 27 04:30:59.765798 2018] [mpm_prefork:notice] [pid 116] AH00163: Apache/2.4.37 (Unix) OpenSSL/1.1.0j PHP/7.2.13 configured -- resuming normal operations
[Thu Dec 27 04:30:59.765874 2018] [core:notice] [pid 116] AH00094: Command line: &#39;httpd -f /bitnami/apache/conf/httpd.conf -D FOREGROUND&#39;
172.17.0.1 - - [27/Dec/2018:04:31:00 +0000] &amp;quot;GET / HTTP/1.1&amp;quot; 200 3718
172.17.0.1 - - [27/Dec/2018:04:31:01 +0000] &amp;quot;GET /wp-includes/js/wp-embed.min.js?ver=5.0.2 HTTP/1.1&amp;quot; 200 753
172.17.0.1 - - [27/Dec/2018:04:31:01 +0000] &amp;quot;GET /wp-includes/css/dist/block-library/theme.min.css?ver=5.0.2 HTTP/1.1&amp;quot; 200 452
172.17.0.1 - - [27/Dec/2018:04:31:01 +0000] &amp;quot;GET /wp-includes/css/dist/block-library/style.min.css?ver=5.0.2 HTTP/1.1&amp;quot; 200 4281
172.17.0.1 - - [27/Dec/2018:04:31:01 +0000] &amp;quot;GET /wp-content/themes/twentynineteen/style.css?ver=1.1 HTTP/1.1&amp;quot; 200 19371
172.17.0.1 - - [27/Dec/2018:04:31:01 +0000] &amp;quot;GET /wp-content/themes/twentynineteen/print.css?ver=1.1 HTTP/1.1&amp;quot; 200 1230
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that folks is all I have for now, be sure to check out the &lt;a href=&#34;https://ksonnet.io/docs/&#34;&gt;Ksonnet official documentation&lt;/a&gt; and &lt;code&gt;ks help&lt;/code&gt; to know more about what ksonnet can do to help you deploy your applications to any kubernetes cluster.&lt;/p&gt;

&lt;h3 id=&#34;errata&#34;&gt;Errata&lt;/h3&gt;

&lt;p&gt;If you spot any error or have any suggestion, please send me a message so it gets fixed.&lt;/p&gt;

&lt;p&gt;Also you can check the source code and changes in the &lt;a href=&#34;https://github.com/kainlite/kainlite.github.io&#34;&gt;generated code&lt;/a&gt; and the &lt;a href=&#34;https://github.com/kainlite/blog&#34;&gt;sources here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Deploying my apps with Helm</title>
      <link>https://kainlite.github.io/blog/deploying_my_apps_with_helm/</link>
      <pubDate>Mon, 24 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kainlite.github.io/blog/deploying_my_apps_with_helm/</guid>
      <description>

&lt;h3 id=&#34;deploying-my-apps-with-helm&#34;&gt;&lt;strong&gt;Deploying my apps with Helm&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;If you are already familiar with &lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt;, and the different types of kubernetes workloads / resource types you might be wondering how to install apps directly to kubernetes, yes, you don&amp;rsquo;t have to re-invent the wheel for your mysql installation, or your postgres, or nginx, jenkins, You name it. Helm solves that problem with &lt;a href=&#34;https://github.com/helm/charts&#34;&gt;Charts&lt;/a&gt;, this list has the official charts maintained by the community, where the folder incubator may refer to charts that are still not compliant with the &lt;a href=&#34;https://github.com/helm/charts/blob/master/CONTRIBUTING.md#technical-requirements&#34;&gt;technical requirements&lt;/a&gt; but probably usable and the folder stable is for &lt;em&gt;graduated&lt;/em&gt; charts. This is not the only source of charts as you can imagine, You can use any source for your charts, even just the &lt;a href=&#34;https://docs.helm.sh/using_helm/#helm-install-installing-a-package&#34;&gt;tgz&lt;/a&gt; files, as we will see in this post.&lt;/p&gt;

&lt;p&gt;How do I search for charts?:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm search wordpress
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
stable/wordpress        3.3.0           4.9.8           Web publishing platform for building blogs and websites.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I&amp;rsquo;m not a fan of Wordpress or PHP itself, but it seems like the most common example everywhere. As we can see here it says stable/wordpress so we know that we&amp;rsquo;re using the official repo in the folder stable, but what if we don&amp;rsquo;t want that chart, but someone else provides one with more features or something that You like better. Let&amp;rsquo;s use the one from &lt;a href=&#34;https://bitnami.com/stack/wordpress/helm&#34;&gt;Bitnami&lt;/a&gt;, so if we check their page you can select different kind of deployments but for it to work we need to add another external repo:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;helm repo add bitnami https://charts.bitnami.com/bitnami
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So if we search again we will now see two options (at the moment of this writing, the latest version is actually 5.0.2):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm search wordpress
NAME                    CHART VERSION   APP VERSION     DESCRIPTION
bitnami/wordpress       5.0.2           5.0.2           Web publishing platform for building blogs and websites.
stable/wordpress        3.3.0           4.9.8           Web publishing platform for building blogs and websites.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check the &lt;a href=&#34;https://github.com/helm/charts/tree/master/stable/wordpress&#34;&gt;documentation&lt;/a&gt; of the chart to create our &lt;code&gt;values.yaml&lt;/code&gt; file, note that in this example the stable wordpress chart it&amp;rsquo;s also maintained by Bitnami, so they have the same configuration :), this won&amp;rsquo;t always be the case but it simplifies things for us.&lt;/p&gt;

&lt;p&gt;Our example &lt;code&gt;values.yaml&lt;/code&gt; will look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wordpressBlogName: &amp;quot;Testing Helm Charts&amp;quot;
persistence:
  size: 1Gi
ingress:
  enabled: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will only change the blog name by default, the persistent volume size and also enable &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34;&gt;ingress&lt;/a&gt; (Our app should be available through &lt;code&gt;wordpress.local&lt;/code&gt; inside the cluster), if you are using minikube be sure to enable the &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34;&gt;ingress&lt;/a&gt; addon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ minikube addons enable ingress
ingress was successfully enabled
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then install &lt;code&gt;stable/wordpress&lt;/code&gt; or &lt;code&gt;bitnami/wordpress&lt;/code&gt;, we will follow up with the one from Bitnami repo.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm install bitnami/wordpress \
--set image.repository=bitnami/wordpress \
--set image.tag=5.0.2 \
-f values.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As it&amp;rsquo;s a common good practice to use specific versions we will do it here, it&amp;rsquo;s better to do it this way because you can easily move between known versions and also avoid unknown states, this can happen by misunderstanding what latest means, &lt;a href=&#34;https://medium.com/@mccode/the-misunderstood-docker-tag-latest-af3babfd6375&#34;&gt;follow the example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You should see something like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;NAME:   plucking-condor
LAST DEPLOYED: Mon Dec 24 13:06:38 2018
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Pod(related)
NAME                                        READY  STATUS             RESTARTS  AGE
plucking-condor-wordpress-84845db8b5-hkqhc  0/1    ContainerCreating  0         0s
plucking-condor-mariadb-0                   0/1    Pending            0         0s

==&amp;gt; v1/Secret

NAME                       AGE
plucking-condor-mariadb    0s
plucking-condor-wordpress  0s

==&amp;gt; v1/ConfigMap
plucking-condor-mariadb        0s
plucking-condor-mariadb-tests  0s

==&amp;gt; v1/PersistentVolumeClaim
plucking-condor-wordpress  0s

==&amp;gt; v1/Service
plucking-condor-mariadb    0s
plucking-condor-wordpress  0s

==&amp;gt; v1beta1/Deployment
plucking-condor-wordpress  0s

==&amp;gt; v1beta1/StatefulSet
plucking-condor-mariadb  0s

==&amp;gt; v1beta1/Ingress
wordpress.local-plucking-condor  0s


NOTES:
1. Get the WordPress URL:

  You should be able to access your new WordPress installation through
  http://wordpress.local/admin

2. Login with the following credentials to see your blog

  echo Username: user
  echo Password: $(kubectl get secret --namespace default plucking-condor-wordpress -o jsonpath=&amp;quot;{.data.wordpress-password}&amp;quot; | base64 --decode)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on the cluster provider or installation itself, you might need to replace the &lt;code&gt;persistence.storageClass&lt;/code&gt; to match what your cluster has, note that in the values file is represented like JSON with dot notation but in your &lt;code&gt;values.yaml&lt;/code&gt; you need to stick to YAML format and indent &lt;code&gt;storageClass&lt;/code&gt; under persistence as usual, the kubernetes API parses and uses JSON but YAML seems more human friendly.&lt;/p&gt;

&lt;p&gt;At this point we should a working wordpress installation, also move between versions, but be aware that the application is in charge of the database schema and updating it to match what the new version needs, this can also be troublesome rolling back or when downgrading, so if you use persistent data &lt;em&gt;ALWAYS&lt;/em&gt; have a working backup, because when things go south, you will want to quickly go back to a known state, also note that I said &amp;ldquo;working backup&amp;rdquo;, yes, test that the backup works and that You can restore it somewhere else before doing anything destructive or that can has repercussions, this will bring you peace of mind and better ways to organize yourself while upgrading, etc.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s check that all resources are indeed working and that we can use our recently installed app.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get all
NAME                                             READY     STATUS        RESTARTS   AGE
pod/plucking-condor-mariadb-0                    1/1       Running       0          12m
pod/plucking-condor-wordpress-84845db8b5-hkqhc   1/1       Running       0          12m

NAME                                TYPE           CLUSTER-IP       EXTERNAL-IP      PORT(S)                      AGE
service/kubernetes                  ClusterIP      10.96.0.1        &amp;lt;none&amp;gt;           443/TCP                      37h
service/plucking-condor-mariadb     ClusterIP      10.106.219.59    &amp;lt;none&amp;gt;           3306/TCP                     12m
service/plucking-condor-wordpress   LoadBalancer   10.100.239.163   10.100.239.163   80:31764/TCP,443:32308/TCP   12m

NAME                                        DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/plucking-condor-wordpress   1         1         1            1           12m

NAME                                                   DESIRED   CURRENT   READY     AGE
replicaset.apps/plucking-condor-wordpress-84845db8b5   1         1         1         12m

NAME                                       DESIRED   CURRENT   AGE
statefulset.apps/plucking-condor-mariadb   1         1         12m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can deploy it to a custom namespace (In this case I deployed it to the default namespace), the only change for that would be to set the parameter &lt;code&gt;--namespace&lt;/code&gt; in the &lt;code&gt;helm install&lt;/code&gt; line.&lt;/p&gt;

&lt;p&gt;If you use minikube then ingress will expose a nodeport that we can find using &lt;code&gt;minikube service list&lt;/code&gt; then using the browser or curl to navigate our freshly installed wordpress.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ minikube service list
|-------------|---------------------------|--------------------------------|
|  NAMESPACE  |           NAME            |              URL               |
|-------------|---------------------------|--------------------------------|
| default     | kubernetes                | No node port                   |
| default     | plucking-condor-mariadb   | No node port                   |
| default     | plucking-condor-wordpress | http://192.168.99.100:31764    |
|             |                           | http://192.168.99.100:32308    |
| kube-system | default-http-backend      | http://192.168.99.100:30001    |
| kube-system | kube-dns                  | No node port                   |
| kube-system | kubernetes-dashboard      | No node port                   |
| kube-system | tiller-deploy             | No node port                   |
|-------------|---------------------------|--------------------------------|
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the cloud or on premises this will indeed be different and you should have a publicly available installation using your own domain name (In this case http is at: &lt;a href=&#34;http://192.168.99.100:31764&#34;&gt;http://192.168.99.100:31764&lt;/a&gt; and https at: &lt;a href=&#34;http://192.168.99.100:32308&#34;&gt;http://192.168.99.100:32308&lt;/a&gt;, and &lt;a href=&#34;http://192.168.99.100:30001&#34;&gt;http://192.168.99.100:30001&lt;/a&gt; is the default backend for the ingress controller), your ips can be different but the basics are the same.&lt;/p&gt;

&lt;p&gt;Sample screenshot:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://kainlite.github.io/img/wordpress-example.png&#34; alt=&#34;Wordpress example&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;notes&#34;&gt;Notes&lt;/h3&gt;

&lt;p&gt;As long as we have the &lt;a href=&#34;https://kubernetes.io/docs/concepts/storage/persistent-volumes/&#34;&gt;persistent volume&lt;/a&gt; our data should be preserved in this case the PV is used for tha database, but we could add another volume to preserve images, etc.&lt;/p&gt;

&lt;p&gt;Clean everything up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;helm del --purge plucking-condor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all I have for now, I will be adding more content next week.&lt;/p&gt;

&lt;h3 id=&#34;don-t-repeat-yourself&#34;&gt;Don&amp;rsquo;t Repeat Yourself&lt;/h3&gt;

&lt;p&gt;DRY is a good design goal and part of the art of a good template is knowing when to add a new template and when to update or use an existing one. While helm and go helps with that, there is no perfect tool so we will explore other options in the following posts, explore what the community provides and what seems like a suitable tool for you. Happy Helming!.&lt;/p&gt;

&lt;h3 id=&#34;upcoming-topics&#34;&gt;Upcoming topics&lt;/h3&gt;

&lt;p&gt;The following posts will be about package managers, development deployment tools, etc. It&amp;rsquo;s hard to put all the tools in a category, but they are trying to solve similar problems in different ways, and we will be exploring the ones that seem more promising to me, if you would like me to cover any other tool/project/whatever, just send me a message :)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Getting started with Ksonnet and friends.&lt;/li&gt;
&lt;li&gt;Getting started with Skaffold.&lt;/li&gt;
&lt;li&gt;Getting started with Gitkube.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;errata&#34;&gt;Errata&lt;/h3&gt;

&lt;p&gt;If you spot any error or have any suggestion, please send me a message so it gets fixed.&lt;/p&gt;

&lt;p&gt;Also you can check the source code and changes in the &lt;a href=&#34;https://github.com/kainlite/kainlite.github.io&#34;&gt;generated code&lt;/a&gt; and the &lt;a href=&#34;https://github.com/kainlite/blog&#34;&gt;sources here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Getting started with Helm</title>
      <link>https://kainlite.github.io/blog/getting_started_with_helm/</link>
      <pubDate>Sun, 23 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kainlite.github.io/blog/getting_started_with_helm/</guid>
      <description>

&lt;h3 id=&#34;introduction&#34;&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;This tutorial will show you how to create a simple chart and also how to deploy it to kubernetes using &lt;a href=&#34;https://helm.sh/&#34;&gt;Helm&lt;/a&gt;, in the examples I will be using &lt;a href=&#34;https://kubernetes.io/docs/tasks/tools/install-minikube&#34;&gt;minikube&lt;/a&gt; or you can &lt;a href=&#34;https://github.com/kainlite/kainlite.github.io&#34;&gt;check out this repo&lt;/a&gt; that has a good overview of minikube, once installed and started (&lt;code&gt;minikube start&lt;/code&gt;) that command will download and configure the local environment, you can follow with the following example:&lt;/p&gt;

&lt;p&gt;Create the chart:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;helm create hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Always use valid DNS names if you are going to have services, otherwise you will have issues later on.&lt;/p&gt;

&lt;p&gt;Inspect the contents, as you will notice every resource is just a kubernetes resource with some placeholders and basic logic to get something more reusable:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;cd hello-world

charts       &amp;lt;--- Dependencies, charts that your chart depends on.
Chart.yaml   &amp;lt;--- Metadata mostly, defines the version of your chart, etc.
templates    &amp;lt;--- Here is where the magic happens.
values.yaml  &amp;lt;--- Default values file (this is used to replace in the templates at runtime)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: the following link explains the basics of &lt;a href=&#34;https://docs.helm.sh/developing_charts/#managing-dependencies-manually-via-the-charts-directory&#34;&gt;dependencies&lt;/a&gt;, your chart can have as many dependencies as you need, the only thing that you need to do is add or install the other charts as dependencies.&lt;/p&gt;

&lt;p&gt;The file &lt;code&gt;values.yaml&lt;/code&gt; by default will look like the following snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;replicaCount: 1

image:
  repository: nginx
  tag: stable
  pullPolicy: IfNotPresent

nameOverride: &amp;quot;&amp;quot;
fullnameOverride: &amp;quot;&amp;quot;

service:
  type: ClusterIP
  port: 80

ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: &amp;quot;true&amp;quot;
  path: /
  hosts:
    - chart-example.local
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources: {}
nodeSelector: {}
tolerations: []
affinity: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step would be to check the &lt;code&gt;templates&lt;/code&gt; folder:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;deployment.yaml  &amp;lt;--- Standard kubernetes deployment with go templates variables.
_helpers.tpl     &amp;lt;--- This file defines some common variables.
ingress.yaml     &amp;lt;--- Ingress route, etc.
NOTES.txt        &amp;lt;--- Once deployed this file will display the details of our deployment, usually login data, how to connect, etc.
service.yaml     &amp;lt;--- The service that we will use internally and/or via ingress to reach our deployed service.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go &lt;a href=&#34;https://blog.gopheracademy.com/advent-2017/using-go-templates/&#34;&gt;templates&lt;/a&gt; basics, if you need a refresher or a crash course in go templates, also always be sure to check Helm&amp;rsquo;s own &lt;a href=&#34;https://github.com/helm/helm/blob/master/docs/chart_template_guide/functions_and_pipelines.md&#34;&gt;documentation&lt;/a&gt; and also some &lt;a href=&#34;https://github.com/helm/helm/blob/master/docs/charts_tips_and_tricks.md&#34;&gt;tips and tricks&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check the &lt;a href=&#34;https://kubernetes.io/docs/concepts/workloads/controllers/deployment/&#34;&gt;deployment&lt;/a&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: apps/v1beta2
kind: Deployment
metadata:
  name: {{ include &amp;quot;hello-world.fullname&amp;quot; . }}
  labels:
    app.kubernetes.io/name: {{ include &amp;quot;hello-world.name&amp;quot; . }}
    helm.sh/chart: {{ include &amp;quot;hello-world.chart&amp;quot; . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  replicas: {{ .Values.replicaCount }}
  selector:
    matchLabels:
      app.kubernetes.io/name: {{ include &amp;quot;hello-world.name&amp;quot; . }}
      app.kubernetes.io/instance: {{ .Release.Name }}
  template:
    metadata:
      labels:
        app.kubernetes.io/name: {{ include &amp;quot;hello-world.name&amp;quot; . }}
        app.kubernetes.io/instance: {{ .Release.Name }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: &amp;quot;{{ .Values.image.repository }}:{{ .Values.image.tag }}&amp;quot;
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /
              port: http
          readinessProbe:
            httpGet:
              path: /
              port: http
          resources:
{{ toYaml .Values.resources | indent 12 }}
    {{- with .Values.nodeSelector }}
      nodeSelector:
{{ toYaml . | indent 8 }}
    {{- end }}
    {{- with .Values.affinity }}
      affinity:
{{ toYaml . | indent 8 }}
    {{- end }}
    {{- with .Values.tolerations }}
      tolerations:
{{ toYaml . | indent 8 }}
    {{- end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see everything will get replaced by what you define in the &lt;code&gt;values.yaml&lt;/code&gt; file and everything is under &lt;code&gt;.Values&lt;/code&gt; unless you define a local variable or some other variable using helpers for example.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check the &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/service/&#34;&gt;service&lt;/a&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apiVersion: v1
kind: Service
metadata:
  name: {{ include &amp;quot;hello-world.fullname&amp;quot; . }}
  labels:
    app.kubernetes.io/name: {{ include &amp;quot;hello-world.name&amp;quot; . }}
    helm.sh/chart: {{ include &amp;quot;hello-world.chart&amp;quot; . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }}
      targetPort: http
      protocol: TCP
      name: http
  selector:
    app.kubernetes.io/name: {{ include &amp;quot;hello-world.name&amp;quot; . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s check the &lt;a href=&#34;https://kubernetes.io/docs/concepts/services-networking/ingress/&#34;&gt;ingress&lt;/a&gt; file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{- if .Values.ingress.enabled -}}
{{- $fullName := include &amp;quot;hello-world.fullname&amp;quot; . -}}
{{- $ingressPath := .Values.ingress.path -}}
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: {{ $fullName }}
  labels:
    app.kubernetes.io/name: {{ include &amp;quot;hello-world.name&amp;quot; . }}
    helm.sh/chart: {{ include &amp;quot;hello-world.chart&amp;quot; . }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- with .Values.ingress.annotations }}
  annotations:
{{ toYaml . | indent 4 }}
{{- end }}
spec:
{{- if .Values.ingress.tls }}
  tls:
  {{- range .Values.ingress.tls }}
    - hosts:
      {{- range .hosts }}
        - {{ . | quote }}
      {{- end }}
      secretName: {{ .secretName }}
  {{- end }}
{{- end }}
  rules:
  {{- range .Values.ingress.hosts }}
    - host: {{ . | quote }}
      http:
        paths:
          - path: {{ $ingressPath }}
            backend:
              serviceName: {{ $fullName }}
              servicePort: http
  {{- end }}
{{- end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The ingress file is one of the most interesting ones in my humble opinion because it has a if else example and also local variables (&lt;code&gt;$fullName&lt;/code&gt; for example), also iterates over a possible slice of dns record names (hosts), and the same if you have certs for them (a good way to get let&amp;rsquo;s encrypt certificates automatically is using cert-manager, in the next post I will expand on this example adding a basic web app with mysql and ssl/tls).&lt;/p&gt;

&lt;p&gt;After checking that everything is up to our needs the only thing missing is to finally deploy it to kubernetes (But first let&amp;rsquo;s install tiller):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm init
$HELM_HOME has been configured at /home/gabriel/.helm.

Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.

Please note: by default, Tiller is deployed with an insecure &#39;allow unauthenticated users&#39; policy.
To prevent this, run `helm init` with the --tiller-tls-verify flag.
For more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation
Happy Helming!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that many of the complains that Helm receives are because of the admin-y capabilities that Tiller has. A good note on the security issues that Tiller can suffer and some possible mitigation alternatives can be found on the &lt;a href=&#34;https://engineering.bitnami.com/articles/helm-security.html&#34;&gt;Bitnami page&lt;/a&gt;, this mostly applies to multi-tenant clusters. And also be sure to check &lt;a href=&#34;https://docs.helm.sh/using_helm/#securing-your-helm-installation&#34;&gt;Securing Helm&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Deploy our chart:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm install --name my-nginx -f values.yaml .
NAME:   my-nginx
LAST DEPLOYED: Sun Dec 23 00:30:11 2018
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Service
NAME                  AGE
my-nginx-hello-world  0s

==&amp;gt; v1beta2/Deployment
my-nginx-hello-world  0s

==&amp;gt; v1/Pod(related)

NAME                                   READY  STATUS   RESTARTS  AGE
my-nginx-hello-world-6f948db8d5-s76zl  0/1    Pending  0         0s

NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l &amp;quot;app.kubernetes.io/name=hello-world,app.kubernetes.io/instance=my-nginx&amp;quot; -o jsonpath=&amp;quot;{.items[0].metadata.name}&amp;quot;)
  echo &amp;quot;Visit http://127.0.0.1:8080 to use your application&amp;quot;
  kubectl port-forward $POD_NAME 8080:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our deployment was successful and we can see that our pod is waiting to be scheduled.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check that our service is there:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl get services
NAME                   TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
kubernetes             ClusterIP   10.96.0.1       &amp;lt;none&amp;gt;        443/TCP   1h
my-nginx-hello-world   ClusterIP   10.111.222.70   &amp;lt;none&amp;gt;        80/TCP    5m
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And now we can test that everything is okay by running another pod in interactive mode, for example:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl run -i --tty alpine --image=alpine -- sh
If you don&#39;t see a command prompt, try pressing enter.

/ # apk add curl
fetch http://dl-cdn.alpinelinux.org/alpine/v3.8/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.8/community/x86_64/APKINDEX.tar.gz
(1/5) Installing ca-certificates (20171114-r3)
(2/5) Installing nghttp2-libs (1.32.0-r0)
(3/5) Installing libssh2 (1.8.0-r3)
(4/5) Installing libcurl (7.61.1-r1)
(5/5) Installing curl (7.61.1-r1)
Executing busybox-1.28.4-r2.trigger
Executing ca-certificates-20171114-r3.trigger
OK: 6 MiB in 18 packages

/ # curl -v my-nginx-hello-world
* Rebuilt URL to: my-nginx-hello-world/
*   Trying 10.111.222.70...
* TCP_NODELAY set
* Connected to my-nginx-hello-world (10.111.222.70) port 80 (#0)
&amp;gt; GET / HTTP/1.1
&amp;gt; Host: my-nginx-hello-world
&amp;gt; User-Agent: curl/7.61.1
&amp;gt; Accept: */*
&amp;gt;
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Server: nginx/1.14.2
&amp;lt; Date: Sun, 23 Dec 2018 03:45:31 GMT
&amp;lt; Content-Type: text/html
&amp;lt; Content-Length: 612
&amp;lt; Last-Modified: Tue, 04 Dec 2018 14:44:49 GMT
&amp;lt; Connection: keep-alive
&amp;lt; ETag: &amp;quot;5c0692e1-264&amp;quot;
&amp;lt; Accept-Ranges: bytes
&amp;lt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;Welcome to nginx!&amp;lt;/title&amp;gt;
&amp;lt;style&amp;gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;Welcome to nginx!&amp;lt;/h1&amp;gt;
&amp;lt;p&amp;gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;For online documentation and support please refer to
&amp;lt;a href=&amp;quot;http://nginx.org/&amp;quot;&amp;gt;nginx.org&amp;lt;/a&amp;gt;.&amp;lt;br/&amp;gt;
Commercial support is available at
&amp;lt;a href=&amp;quot;http://nginx.com/&amp;quot;&amp;gt;nginx.com&amp;lt;/a&amp;gt;.&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;&amp;lt;em&amp;gt;Thank you for using nginx.&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
* Connection #0 to host my-nginx-hello-world left intact
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And voila we see our nginx deployed there and accessible via service name to our other pods (this is fantastic for microservices).&lt;/p&gt;

&lt;p&gt;Our current deployment can be checked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm ls
NAME            REVISION        UPDATED                         STATUS          CHART                   APP VERSION     NAMESPACE
my-nginx        1               Sun Dec 23 00:30:11 2018        DEPLOYED        hello-world-0.1.0       1.0             default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The last example would be to upgrade our deployment, lets change the &lt;code&gt;tag&lt;/code&gt; in the &lt;code&gt;values.yaml&lt;/code&gt; file from &lt;code&gt;stable&lt;/code&gt; to &lt;code&gt;mainline&lt;/code&gt; and update also the metadata file (&lt;code&gt;Chart.yaml&lt;/code&gt;) to let Helm know that this is a new version of our chart.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt; $ helm upgrade my-nginx . -f values.yaml
Release &amp;quot;my-nginx&amp;quot; has been upgraded. Happy Helming!
LAST DEPLOYED: Sun Dec 23 00:55:22 2018
NAMESPACE: default
STATUS: DEPLOYED

RESOURCES:
==&amp;gt; v1/Pod(related)
NAME                                   READY  STATUS             RESTARTS  AGE
my-nginx-hello-world-6f948db8d5-s76zl  1/1    Running            0         25m
my-nginx-hello-world-c5cdcc95c-shgc6   0/1    ContainerCreating  0         0s

==&amp;gt; v1/Service

NAME                  AGE
my-nginx-hello-world  25m

==&amp;gt; v1beta2/Deployment
my-nginx-hello-world  25m


NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default -l &amp;quot;app.kubernetes.io/name=hello-world,app.kubernetes.io/instance=my-nginx&amp;quot; -o jsonpath=&amp;quot;{.items[0].metadata.name}&amp;quot;)
  echo &amp;quot;Visit http://127.0.0.1:8080 to use your application&amp;quot;
  kubectl port-forward $POD_NAME 8080:80
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I always specify the -f values.yaml just for explicitness.&lt;/p&gt;

&lt;p&gt;It seems that our upgrade went well, let&amp;rsquo;s see what Helm sees&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm ls
NAME            REVISION        UPDATED                         STATUS          CHART                   APP VERSION     NAMESPACE
my-nginx        2               Sun Dec 23 00:55:22 2018        DEPLOYED        hello-world-0.1.1       1.0             default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But before we go let&amp;rsquo;s validate that it did deployed the nginx version that we wanted to have:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl exec my-nginx-hello-world-c5cdcc95c-shgc6 -- /usr/sbin/nginx -v
nginx version: nginx/1.15.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the moment of this writing mainline is 1.15.7, we could rollback to the previous version by doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm rollback my-nginx 1
Rollback was a success! Happy Helming!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Basically this command needs a deployment name &lt;code&gt;my-nginx&lt;/code&gt; and the revision number to rollback to in this case &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s check the versions again:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ kubectl exec my-nginx-hello-world-6f948db8d5-bsml2 -- /usr/sbin/nginx -v
nginx version: nginx/1.14.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s clean up:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ helm del --purge my-nginx
release &amp;quot;my-nginx&amp;quot; deleted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need to see what will be sent to the kubernetes API then you can use the following command (sometimes it&amp;rsquo;s really useful for debugging or to inject a sidecar using pipes):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ helm template . -name my-nginx -f values.yaml
# Source: hello-world/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: ame-hello-world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that folks is all I have for now, be sure to check own &lt;a href=&#34;https://docs.helm.sh/&#34;&gt;Helm Documentation&lt;/a&gt; and &lt;code&gt;helm help&lt;/code&gt; to know more about what helm can do to help you deploy your applications to any kubernetes cluster.&lt;/p&gt;

&lt;h3 id=&#34;don-t-repeat-yourself&#34;&gt;Don&amp;rsquo;t Repeat Yourself&lt;/h3&gt;

&lt;p&gt;DRY is a good design goal and part of the art of a good template is knowing when to add a new template and when to update an existing one. While you&amp;rsquo;re figuring that out, accept that you&amp;rsquo;ll be doing some refactoring. Helm and go makes that easy and fast.&lt;/p&gt;

&lt;h3 id=&#34;upcoming-topics&#34;&gt;Upcoming topics&lt;/h3&gt;

&lt;p&gt;The following posts will be about package managers, development deployment tools, etc. It&amp;rsquo;s hard to put all the tools in a category, but they are trying to solve similar problems in different ways, and we will be exploring the ones that seem more promising to me, if you would like me to cover any other tool/project/whatever, just send me a message :)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kainlite.github.io/blog/deploying_my_apps_with_helm/&#34;&gt;Expand on helm, search and install community charts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://kainlite.github.io/blog/getting_started_with_ksonnet/&#34;&gt;Getting started with Ksonnet and friends&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Getting started with Skaffold.&lt;/li&gt;
&lt;li&gt;Getting started with Gitkube.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;errata&#34;&gt;Errata&lt;/h3&gt;

&lt;p&gt;If you spot any error or have any suggestion, please send me a message so it gets fixed.&lt;/p&gt;

&lt;p&gt;Also you can check the source code and changes in the &lt;a href=&#34;https://github.com/kainlite/kainlite.github.io&#34;&gt;generated code&lt;/a&gt; and the &lt;a href=&#34;https://github.com/kainlite/blog&#34;&gt;sources here&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
